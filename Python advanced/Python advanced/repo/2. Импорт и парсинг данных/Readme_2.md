Часть 2: импорт и парсинг данных

#Импорт данных

Задание
Изучите API Геокодера Яндекса
tech.yandex.ru/maps/geocoder/doc/desc/concepts/input_params-docpage/
и получите ключ API для него в кабинете разработчика.
Выполните запрос к API и узнайте долготу точки на карте (Point) для города Самара.
Внимание: активация ключа Геокодера Яндекса может занимать несколько часов (до суток).
В качестве запасного варианта можно использовать этот ключ - 3f355b88-81e9-4bbf-a0a4-eb687fdea256 - он только для выполнения этого задания!
Решение:
1)	подключаем библиотеки requests (для выполнение запроса) и json (для получения контента) 
2)	в качестве геокода используем нужный нам город: "Самара"
3)	apikey берём предоставленный нам в задании,
4)	формат ответа указываем json,
5)	результат, максимальное количество возвращаемых объектов указываем 1 (по умолчанию 10)
6)	полученный ответ присваиваем в объект geo
7)	находим точку центра, последовательно сокращая наш объект

#Парсинг данных

Задание

Получите данные по котировкам акций со страницы:
mfd.ru/marketdata/?id=5&group=16&mode=3&sortHeader=name&sortOrder=1&selectedDate=01.11.2019
и найдите, по какому тикеру был максимальный рост числа сделок (в процентах) за 1 ноября 2019 года.


Решение:
1)	подключаем нужные нам библиотеки
2)	получаем данные со страницы, по указанной ссылке
3)	преобразуем её в объект
4)	получаем данные из тега "table", id у которого имеет значение "marketDatalist"
5)	создаём список, где будем хранить данные строк
6)	получаем все данные, которые имеют тег 'tr'
7)	обходим циклом полученные данные, из каждой строки (тега "td"), получаем содержимое в виде текста
8)	в строку (table_row), с помощью генератора осуществляем добавления текста из ячеек (table_data), 
9)	в table_data обновляем данные из содержимого с тегом 'td'
10)	с помощью параметра strip=True убираем переносы строк и пробелы
11)	если длина строки больше нуля, мы в список строк, добавляем полученную нами из table_rows строку
12)	создаём фрейм данных куда добавляем наш список "rows", присваиваем нужные нам имена для колонок
13)	в созданный фрейм, из серии данных "Сделки" добавляем только те значения, которые не равны "N/A"
14)	из столбца "процент сделок" все символы "дефис" заменяем на символ "минус", так как их наличие как они затрудняют сортировку
15)	в получившихся строках знак процента % заменяем на пустое значения
16)	полученные данные преобразуем к типу float
17)	в этом фрейме данных из столбца "% сделок" формируем индекс
18)	сортируем данные по индексу, в порядке убывания (ascending=False)
19)	выводим первую позицию, из серии данных "Тикер", это и является ответом

#Веб-скрепинг

Задание

Используя парсинг данных с маркетплейса beru.ru, найдите, на сколько литров отличается общий объем холодильников Саратов 263 и Саратов 452?
Для парсинга можно использовать зеркало страницы beru.ru с результатами для холодильников Саратов по адресу:
video.ittensive.com/data/018-python-advanced/beru.ru/
Решение:
1)	задаём User-Agent и указываем ссылку на сайт
2)	получаем данные со страницы, на которой находятся ссылки на страницы холодильников
3)	преобразуем их в объект
4)	получаем все теги "a" с классом "_3ioN70chUh Usp3kX1MNT _3Uc73lzxcf", именно в них хранятся ссылки на детальные страницы холодильников
5)	перебираем это список 
6)	если у нас в виде строкового значения появляется запись "Саратов 263", получаем данные из атрибута "href" этой ссылки, это путь к детальной странице холодильника
7)	аналогичную операцию проделываем с "Саратов 452
8)	создаём функцию, которая на вход принимает атрибут "href"
9)	по нему выстраиваем адрес для получения контента с этой странице, детальной странице холодильника
10)	преобразуем эти данные в объект
11)	из этого объекта функция получает все данные, которые имеют тег span, c классом"_112Tad-7AP"
12)	далее создаётся генератор, который в третьем элементе volume.get_text() (именно под этим индексом находится нужный нам объём voluem) c помощью метода get_text() приводим значение к строковому значению
13)	обходим volume[2].get_text() циклом и получаем все символы строки, и если символ цифра, то мы его вернём
14)	с помощью ''.join объединяем эти символы, через пустую строку, таким образом мы выделили все цифры из строки
15)	если мы получаем ink_263 и link_452, то мы передаём их в качестве параметров в функцию volume_calculation()
16)	рассчитываем разницу между объёмами холодильников Саратов-263 и Сартов-452
17)	узнаем наибольшее и наименьшее из этих чисел
18)	далее из наибольшего отнимаем наименьшее
19)	выводим ответ

#Работа с SQL

Задание

Соберите данные о моделях холодильников Саратов с маркетплейса beru.ru: URL, название, цена, размеры, общий объем, объем холодильной камеры.
Создайте соответствующие таблицы в SQLite базе данных и загрузите полученные данные в таблицу beru_goods.
Для парсинга можно использовать зеркало страницы beru.ru с результатами для холодильников Саратов по адресу:
video.ittensive.com/data/018-python-advanced/beru.ru/
Решение:
1)	подключаем нужные нам библеотеки
2)	создаём функцию, которая будет приводить к числу, передаваемою ей в качестве параметра, строку
3)	проверяем что символ - цифра, и объединяем его, с возвращаемым значением, через пустую строку
4)	получаем контент с сайта beru.ru, с адреса, который представляет собой страницу, на которой в поле поиска товаров выбран "Саратов", + ссылка на детальную страницу товара
5)	преобразуем контент в объект
6)	получаем название холодильника, оно храниться в первом теге h1
7)	который имеет класс "_3TfWusA7bt", преобразуем полученную информацию в текст
8)	находим цену холодильника
9)	получаем первый тег span, который имеет "data-tid", равный "c3eaad93"
10)	получаем все теги "sapn", которые имеют класс "sapn", преобразуем информацию в текст
11)	именно в этих тегах хранятся нужные нам, параметры холодильника
12)	создаём переменные для хранения параметров, на тот случай, если при паргсинге они вдруг не будут определены: ширины, глубины, высоты, общий объем, объем холодильной камеры
13)	обходим циклом данные в которых храниться информация о параметрах холодильника
14)	преобразуем эту информацию в текст
15)	если в теге присутствует данная строка "ШхВхГ", то эту строку мы разделяем по двоеточию, затем вторую часть данной строки (индекс [1]) мы ещё раз делим по символу "х", первое значение в получившейся строке, является значением ширины
16)	получаем его, и преобразуем к типу данных float, глубина, второе значение, высота третье, 
17)	чтобы избавиться от сантиметров, делим строку по пробелу, и берём её левую часть, 
18)	если в теге присутствует данная строка "общий объем", то мы присваиваем переменной volume, значение этой строки
19)	функция возвращает ссылку детальной страницы холодильника, название, цену, ширину, глубину, высоту, общий объём и объём холодильной камеры
20)	в созданную, для получения данных со страницы функцию, передаём одну из детальных страниц, модели холодильника
21)	получаем контент со страницы, на которой хранятся все ссылки на детальные страницы холодильника
22)	преобразуем контент в объект
23)	получаем все данные со из ссылок, с атрибутом "а", с классом "grid_snippet_react-link"
24)	создаём массив, для того чтобы составить список ссылок детальных страниц
25)	обходим циклом набор полученных ссылок если у ссылки есть атрибут href и в её текстовом представлении есть значение "Сартов"
26)	в массив data добавляем результат работы функции find_data()
27)	подключаемся к базе данных "data.db3"
28)	в базе данных создаём таблицу "beru_goods", полями id (первичный ключ, автоинкрементен, не null), url (text), title (text), price (целочисленное значение, по умолчанию равно 0), url (text), title (text), price (целочисленное значение, по умолчанию равно 0), depth (дробное знчение, по умолчанию равно 0.0), height  (дробное знчение, по умолчанию равно 0.0), volume (целочисленное значение, по умолчанию равно 0), freezer price (целочисленное значение, по умолчанию равно 0)
29)	выполняем коммит результата
30)	в базу данных, с помощью запроса INSERT мы передаём данные, в таблицу beru_goods, в качестве передаваемых параметров указываем,  массив data, используем executemany, для того, чтобы добавить множество строк одновременно
31)	выводим все значения из созданной базы данных
32)	закрываем соединения с базой данных